<!DOCTYPE html>
<html>
<head>
    <title>Python Course</title>
    <meta charset="UTF-8">
    <base href="..">

    <link rel="stylesheet" href="python/highlight/styles/agate.css">
    <script src="python/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <style>
        @font-face {
          font-family: 'Nova Mono';
          src: url('font/NovaMono-Regular.ttf') format('truetype');
        }

        html, body {
            margin: 0;
            padding: 0;
        }

        body {
            background: linear-gradient(to top, #bdc3c7, #2c3e50);
            background-repeat: no-repeat;
            background-attachment: fixed;
            font-family: 'Nova Mono';
            text-align: center;
        }

        svg.header {
            height: 25vh;
            margin-top: 5vh;
            max-width: 80%;
            margin-left: auto;
            margin-right: auto;
        }

        div {
            width: 21cm;
            max-width: 100%;
            box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
            background: #bdc3c7;
            margin-left: auto;
            margin-right: auto;
            padding: 1em;
            color: #2c3e50;
            text-align: justify;
            hyphens: auto;
            margin-bottom: 1em;
        }

        h1 {
            text-align: center;
        }

        p, ul.text {
            font-family: sans-serif;
            line-height: 1.3em;
            font-size: 14pt;
        }

        p, h2, h3 {
            padding-left: 28pt;
            padding-right: 28pt;
        }

        p.question {
            color: red;
            text-align: left;
            font-family: 'Nova Mono';
        }

        p.question::before {
            content: "⛵ ";
        }

        pre {
            margin-left: 30pt;
            margin-right: 30pt;
        }

        code {
            font-family: 'Nova Mono';
            background-color: #2c3e50 !important;
        }

        code.inline {
            all: initial !important;
        }
    </style>
</head>

<body>

<svg version="1.1" class="header" baseProfile="full" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 277 18">
    <style>
        .title {
            font-size: 15px;
            fill: red;
            stroke: yellow;
            stroke-width: 0.3px;
        }
    </style>

    <text x="0" y="3" class="title">Pythons, Pandas &amp; Other Creatures</text>

    <circle cx="55" cy="13" r="5" fill="yellow" opacity="0.8" />
    <circle cx="123" cy="13" r="5" fill="#bdc3c7" opacity="0.8" />
    <circle cx="206.5" cy="13" r="5" fill="red" opacity="0.8" />

</svg>

<div>
<h1>Preface</h1>
<p>"The best way to learn a language is to use it". Is this motto correct in the realm of programming languages as well?
Unlike spoken languages, programming languages always follow some formal set of rules, so isn't it better to simply learn those rules?</p>

<p>Simply learning the rules is not enough because the rules by themselves do not give an intuition that allows the programmer
to use them in the most effective and efficient way.</p>

<p>Moreover, since the rules of programming languages are often quite simple, learning them explicitly might be a 
waste of time, it is better to just start looking at real programs and figuring out the rules along the way.</p>

<p>There is one hazard with this one-hundred-percent-hands-on approach: without knowing the exact rules and theory we may conclude
that a certain way of doing things is the best when in fact it may be not optimal or even wrong. In other words we may acquire
bad habbits.</p>

<p>Therefore, it is better to learn new progrmming languages using the following methodology: first practice and achieve some
working results, but then immidiately reflect on those results and analyse them to induce the correct behaviour. It is
better to perform the latter stage with a teacher, however, expirienced programmers may do it by themselves.</p>
</div>

<div>
<h1>Table of Contents</h1>

<ul>
    <li><a href="python/course.html#basics">Basics</a></li>
    <li><a href="python/course.html#classes">Classes</a></li>
    <li><a href="python/course.html#exceptions">Exceptions</a></li>
    <li><a href="python/course.html#comprehensions">Comprehensions</a></li>
    <li><a href="python/course.html#functions">Functions</a></li>
    <li><a href="python/course.html#closures">Closures</a></li>
    <li><a href="python/course.html#pandas">Pandas</a></li>
    <li><a href="python/course.html#summary">Summary &amp; Solutions</a></li>
</ul>

</div>

<div>
<h1 id="basics">Basics</h1>

<h2>Comments</h2>

<p>Download latest Python interpreter from python.org, run it and execute the following code (type it in the interpreter):</p>
<pre><code class="python"># This is line comment

"""This 
is a
multi
line
string, 
which can be used as comment"""
</code></pre>

<h2>Dynamic Typing</h2>

<p>Python is a <em>dynamically typed</em> programming language. Types are decided at runtime. A special built-in function <em>type</em> returns the type of an object.</p>

<pre><code class="python"># Run the code below in an interpreter:

s = "Hello, World! שלום"
bt = b'Hello'
n = 55
f = 5.5
b = True
null = None

print(type("Hello"))  # print() is used for putting things on screen
print(type(n))
print(type(f))
print(type(b))
print(type(null))
</code></pre>
<h2>Unary and Binary Operations</h2>
<p>Run the code below in an interpreter and answer the questions below:</p>

<pre><code class="python"># Getting input string from the user
name = input('Your name is ')

# Strings can be added and multiplied
print(name + ", very nice to meet you" + ('!' * 10))
</code></pre>

<p class="question">What happens when two strings are added?</p>
<p class="question">What happens when string is multiplied by an integer?</p>

<h3>Arithmetic & Logical Operations</h3>
<p>Checking whether <!-- 322.0625 -\frac{(n^3 + 1456)}{16} > m --><math><mrow><mn>322</mn><mi>.</mi><mn>0625</mn><mo>-</mo><mfrac linethickness="1"><mrow><mrow><mo>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>3</mn></mrow></msup><mo>+</mo><mn>1456</mn><mo>)</mo></mrow></mrow><mrow><mrow><mn>16</mn></mrow></mrow></mfrac><mi>></mi><mi>m</mi></mrow></math> for n=12 and m=150:</p>

<pre><code class="python">n = 12
m = 150
322.0625 - (n ** 3) / 16 > m
</code></pre>
<p>Verifying that 5 < 6 < 8 and that -1 < 0:</p>

<pre><code class="python">(5 < 6 < 8) and (-1 < 0)
</code></pre>
<p>Verifying that binary number 101 (5) xored with 111 (7) equals 010 (4):</p>

<pre><code class="python">5 ^ 7 == 4
</code></pre>
<p>Doing the same by manually converting binary strings to integers:</p>

<pre><code class="python">five = int('101', base=2)
seven = int('111', base=2)

n = five ^ seven

print('decimal:', n)

binary = format(n, 'b')

print('binary:', binary)
</code></pre>

<h2>Lists and Tuples</h2>
<p>List is an array in python. Tuple is a list that cannot be changed.</p>

<pre><code class="python"># Declare a list:
lst = [1, 2, 3, 4, 5]

# Change the values of the list:
lst[0] = 'Hello'
lst[-1] = 20
print(lst)
</code></pre>
<p class="question">Why do you see an error when you try to run the code below?</p>
<pre><code class="python"># Declare the following tuple (tuple is a list that cannot be changed)
tpl = (1, 2, 3, 4, 5)

# Set the value of tpl[0] to 0.
tpl[0] = 0
</code></pre>
<p>What is the complexity of the following operation (assuming the length of lst lst is n):</p>

<pre><code class="python"># in operator checks whether an element is contained in a container:

5 in lst # => True
</code></pre>
<p>For loops can be used to iterate lists and tuples:</p>

<pre><code class="python"># print all values in a list one by one.

for value in lst:
    print(value)
</code></pre>
<h2>Indexing</h2>
<p>The length of any container (string, list, tuple, etc.) is returned by builtin len() function:</p>

<pre><code class="python">x = [1, 2, 3, 4, 5]
print(len(x))
</code></pre>
<p>Strings, lists and tuples can all be indexed and iterated. Indexing a container returns new container
of the same type containing elements from the original one. The syntax of indexing a container x is</p>

<pre><code class="python">x[i:j:k]
</code></pre>
<p>where i, j, k specify the indexes sequence: i, i+k, i+2*k, ..., j. The output container contains
all elements matching the indexes in that sequence in the input container, except the last one.</p>

<p>There are shortcuts that allow avoiding explicit specification of i, j, or k. All the following
boolean expressions True for any non empty container x:</p>

<pre><code class="python">x[i] == x[i:i+1:1]
x[i:j] == x[i:j:1]
x[:j] == x[0:j]
x[:] == x[0:len(x)]
x[-1] == x[-1 + len(x)]
x[::2] == x[0:len(x):2]
x[-1:0:-1] == x[len(x):0:-1]

x = '0123456789'
x[::-1] == x[-1:0:-1] + x[0]
</code></pre>
<p class="question"> Make the interpreter print the values of s[0], s[-1], s[0:3], s[-6:], s[::5], s[::-3] for string s defined below:</p>
<pre><code class="python">s = "Rose is a rose is a rose"
</code></pre>
<p>While lists, tuples and strings can be indexed only be integer, dictionaries can be index by many different types.</p>

<pre><code class="python">capitals = {'Moscow': 'Russia', 'London':, 'United Kingdom', 'Monaco': 'Monaco'}

print('London is the capital of', capitals['London'])
</code></pre>

<h2>List, Tuple Expansion</h2>
<p>In python, multiple assignments can be done in one line:</p>

<pre><code class="python">i, j = 5, 9
print(i, j)
</code></pre>
<p>Finite sequences can be assignment to sequences of variables:</p>

<pre><code class="python">coordinates = ['hello', 8.9, 10]
[x, y, z] = coordinates
print(x, y, z)
</code></pre>

<h2>Functions</h2>
<p>Statement sequences can be put in a functions. Functions are defined and called as follows:</p>

<pre><code class="python">def function_name():
    print('Code inside function') # notice the identation


function_name() # call
function_name() # another call
</code></pre>
<p>Functions can get arguments and return values. The following function gets a string and returns boolean value which tells if a string is a palindrome:</p>

<pre><code class="python">def is_palindrome(s):
    return s == s[::-1]
</code></pre>
<p>To test the function above run:</p>

<pre><code class="python">palindrome("abba")
</code></pre>
<h2>Indentation, Control Flows</h2>
<p>As you've noticed in function declaration, indentation is Python’s way of making blocks of statements.
That is, all statements that may be followed by a block of code are terminated by a colon and the following
lines are indented to the right. The block is terminated by a line which moves again to the left.</p>

<pre><code class="python"># If:

if 4 < 6 < 8:
    if 9 < 5:
        print('Jenny')
    print('Jerry')
else:
    print('Lenny')
    
# While:

i = 0
lst = []
while i < 10:
    lst = lst + [i]
    #lst.append(i)
    i += 1

print(lst)
</code></pre>
<p class="question">What would be the output of the code above (run it in the interpreter to verify your answer)?</p>
<h2>Casting</h2>
<p>Cast from one type to another can be done using built-in functions int, float, list, tuple, bool, etc.</p>

<p class="question">
<p>Print in the interpreter the types and the values of:
- tuple("Anna")
- int(5.5)
- bool([])
- bool([0])</p>

</p>
<h2>Sets and Dictionaries</h2>
<p>Sets and dictionaries are implemented in python with hashtables. They are defained using curly brackets.</p>

<pre><code class="python"># Define a set of strings:
towers = {'Azrieli', 'Electra', 'Time', 'Atrium', 'Sail'}
print(towers)
</code></pre>
<p class="question">What was the complexity of the following expression assuming the set towers contains n elements?</p>
<pre><code class="python">'Electra' in towers
</code></pre>
<p>Dictionaries allow assotiating every key element in a set with a value.</p>

<pre><code class="python"># Define a dictionary:
towers = {'Tel Aviv': ['Azrieli', 'Electra'],
          'Ramat Gan': ['Time', 'Atrium'],
          'Haifa': ['Sail']}
print(towers['Tel Aviv'])
</code></pre>
<p class="question">What is the type of towers["Ramat Gan"]? How do you check it in python?</p>
<p>Alternative to create a dictionary:</p>

<pre><code class="python">x = dict(one=1, two=2, three=3)
y = {'one': 1, 'two': 2, 'three': 3}

print(x == y)
</code></pre>
<h2>Keyword Arguments</h2>
<p>When arguments are passed to a function, they can be past as list (one after another) or as dictionary:</p>

<pre><code class="python">def f(a, b, c):
    print(a, b, c)

f(1, 2, 3)
f(a=1, b=2, c=3)
</code></pre>
<h2>Default Arguments</h2>
<p>When declaring a function, default values can be attached to some arguments -- these arguments
can be ommited when the function is called:</p>

<pre><code class="python">def f(a, b, c=2):
    print(c)

f(1, 1)     # c=2
f(1, 1, 4)  # c=4
</code></pre>
<h2>Importing Standard Library Functions</h2>
<p>Python language has very rich standard library with lots of useful functions. For convinience these functions
are split to different modules. For instance, functions dealing with randomness are put in a module named random.</p>

<p>To use these function the required module must be first imported by its name with import command. For instance,
random module is imported as follows:</p>

<pre><code class="python">import random
</code></pre>
<p>Then module functions can be called:</p>

<pre><code class="python">n = random.randint(0, 10)
</code></pre>
<p>The code above puts random integer between 0 and 10 in variable n.</p>

<h2>Standard Input</h2>
<p>The module sys contains a variable stdin. It is a special variable that can be used in a for loop:</p>

<pre><code class="python">import sys

for line in sys.stdin:
    print(len(line))
</code></pre>
<p>the code above prints the length of every line in the standard input.</p>

<h2>Calling Instance Functions</h2>
<p>Any variable in python is an object: it is assosiated with a predefined list of functions which get the related
object as their first argument.</p>

<p>To call the assosiated functions of an object, similar syntax to calling functions in a module is used.
For instance, there is a function upper() that is associated with string objects and it makes all letters in a string to be uppercase.</p>

<p>Here is how it can be used:</p>

<pre><code class="python">s = "blue rose"
print(s.upper())  # "BLUE ROSE" should be printed
</code></pre>
<h2>Strings</h2>
<p>Strings can be defined with either double-quote or a single quotes:</p>

<pre><code class="python">"a string" == 'a string'
</code></pre>
<p>By default, splitting a line in the middle of a string is forbidden. To declare multi-line
string the quote sign is written three times:</p>

<pre><code class="python">"""This is a multi
line string"""
</code></pre>

<p>String containing calculated expressions objects are called f-strings, they must be prefixed with f-letter.
Expressions are surrounded in an f-string with curly braces:</p>

<pre><code class="python">n = 12
s = f"n = {n}"

print(s)
</code></pre>
<h2>Exercises:</h2>
<h3>Exercise 1: Quotes</h3>
<pre><code class="python"># define a list of Shakespeare quotes
quotes = ["When we are born, we cry...",
          "My mistress' eyes are nothing like the sun...",
          "There never was a story of more woe...",
          "And the rain it raineth every day..."]
</code></pre>
<p>Write the following functions:</p>

<p>- <code class="inline">print_quote(i)</code> that prints quote number i
- <code class="inline">print_quotes(i, j)</code> which prints quotes from i to j (not including j)
- <code class="inline">print_random_quote()</code> which prints a random quote
- <code class="inline">choose_and_print_quote()</code> which lets the user choose a quote and then prints it
- <code class="inline">organazie_quotes()</code> which asks the user each quote whether it is from play or from a sonnet and returns a dictionary with keys "play" and "sonnet" and with a list of quotes for each key.</p>

<h3>Exercise 2: Reflection</h3>
<p>Write a function <code class="inline">remove_non_reflection(d)</code> which gets a dictionary
and removes all keys that are not reflections of their values. That is,
when the function is written the following expression should be equal to True:</p>

<pre><code class="python">remove_non_reflection({"ab": "ba", "b": "a"}) == {"ab": "ba"}
</code></pre>
<h3>Exercise 3: Random Password Generator</h3>
<p>Write a python file named <code class="inline">password_generator.py</code> which contains a function named <code class="inline">generate_password(n)</code>.
The function should return a password of length n (n>2) with the following constrains:</p>

<ul>
<li>The password contains only english lowercase and uppercase letters, digits and the signs "!@#$%^&amp;*".</li>
<li>The password must contains at least one uppercase letter and at least one digit.</li>
</ul>

<p>Add logic that prints a random password of length 8 when the file is executed and not imported.</p>

<p>Hint: Standard library random module contains <code class="inline">random.sample(population, k)</code> function. Look for its description in the internet or with Python's interpreter help function.</p>

<h3>Exercise 4: Echo</h3>
<p>Write a program which reads every line from the standard input and prints it to the standard output.</p>

<p>Hint: for string <code class="inline">s</code>, there is a function <code class="inline">s.strip()</code> which removes any trailing and heading spaces/tabs/newline chars.</p>

</div>

<div id="classes">

<h1>Classes</h1>
<h3>Namespaces</h3>
<p>Namespace is an association between names and values. For instance, any python dictionary can be seen as a namespace:</p>

<pre><code class="python">{'key1': 'value1', 'key2': 'value2'}
</code></pre>

<p>Dictionary defined above assosiates names 'key1' and 'key2' with values 'value1' and 'value2' respectively. To get a value
from dictionary we use brackets: d['key'] gets the value associated with name 'key' from dictionary d.</p>

<p>Python modules are also namespaces with completely different indexing syntax: to get a value of a certain name in module we
write module name followed by a dot followed by the required variable name:</p>

<pre><code class="python">import module

value = module.key 
</code></pre>

<h3>Objects</h3>
<p>Another example of a namespace is an object. Like in dictionaries, values to object instances can be added dynamically,
however the syntax for accessing object's values is similar to that of modules:</p>

<pre><code class="python">obj = object()
obj.x = 'new value' # new values can be added dynamically like in dictionaries

print(obj.x) # values are accessed using the dot syntax
</code></pre>

<h3>Classes</h3>
<p>Other kind of namespace is a class. Functions and variables can be bound together by putting them in the same class.
Classes are defined using the class keyword:</p>

<pre><code class="python">class Mazda:
    NAME = 'MAZDA'

    def go(self, source_location, dest_location):
        # self is passed explicitly when instance function is called
        print(f'Going from {source_location} to {dest_location}')

    def print_slogan(self):
        print("Driving matters")

class Honda:
    NAME = 'HONDA'

    def go(self, source_location, dest_location):
        print(f'Going from {source_location} to {dest_location}')


    def print_slogan(self):
        print('The Power of Dreams')

class Ford:
    NAME = 'FORD'

    def go(self, source_location, dest_location):
        print(f'Going from {source_location} to {dest_location}')

    def print_slogan(self):
        print('Everything We Do is Driven By You')
</code></pre>
<p>To get values from classes we use similar syntax to that of modules and objects:</p>

<pre><code class="python">print(Mazda.NAME)
</code></pre>

<h3>Instances</h3>
<p>A more advanced kind of namespace is an instance. Instance is an object that is also associated with a class. So any
name that was dynamically added to an object and also any name defined in a class can be accessed through an instance.</p>

<p>Instances are created by calling classes as if they were functions.</p>

<pre><code class="python">mazda = Mazda()

mazda.year = 1995 # new values can be added dynamically like in objects
print(mazda.NAME) # class values can be accessed like in classes
</code></pre>
<p>Notice that in the following example, <code class="inline">brand</code> instance is associated with different classes during
loop execution, however, the code still works since all of them have a function <code class="inline">print_slogan()</code>:</p>

<pre><code class="python">brands = [Mazda(), Honda(), Ford()] # list of instances

for brand in brands:
    brand.print_slogan()
</code></pre>
<p>Therefore, if two objects have the same functions then they can be used interchangeably:</p>

<pre><code class="python">i = int(input(f"Pick a number from 0 to {len(brands)}")
car = brands[i]

car.go('LA', 'NY')
</code></pre>
<h3>Inheritance and Lookup Order</h3>
<p>Classes can be inherited:</p>

<pre><code class="python">class Acura(Honda):
    def print_slogan(self):
        print('The road will never be the same.')

acura = Acura()
acura.print_slogan()
acura.go('A', 'B')
`</code></pre>
<p>The lookup order of a name in an instance is as followed: if the name was added to the instance object
then the assisiated value is returned, otherwise, if that name was defined in the instance class then
the value defined in the class is returned. If the name found niether in an object nor in the class then
it is looked up in all the ancestor classes (the classes from which object class was inherited).</p>

<p>The exact lookup order can be checked using __mro__ variable that is automatically attached to all classes (since python3).</p>

<pre><code class="python">print(Acura.__mro__)
</code></pre>
<h3>Instance Argument</h3>
<p>When a function defined in a class is called from an instances, the instance object itself is automatically passed as first argument.</p>

<pre><code class="python">class CLASS:
    def f(self):
        print(self.key)

instance = CLASS()             # create an instance
instance.key = 'object field'  # add a variable to instance object

# CLASS.f can be called either from class namespaces
CLASS.f(instance)

# CLASS.f can also be called from instance.
instance.f() # instance argument is passed automatically
</code></pre>
<p>There is a convenrsion to name instance object argument <code class="inline">self</code>.</p>

<h3>Special Method Names</h3>
<p>Class functions are also called methods. There is a family of methods with predefined names that are called special methods.
These methods are used to implement behaviour of built in operations on instances (such as addition, multiplication and others).</p>

<p>For example, <code class="inline">__add__()</code> method can be used to implement a class whose instances can be added:</p>

<pre><code class="python">class Addable:
    def __add__(self, other):
        result = Addable()
        result.value = self.value + other.value
        return result

x = Addable()
y = Addable()

x.value = 'Hello, '
y.value = 'World!'

z = x + v

print(z.value)
</code></pre>
<p class="question">What does the code above print?</p>

<h3>Constructors</h3>
<p>Special method <code class="inline">__init__()</code> is called when an instance object is created.</p>

<pre><code class="python">class C:
    def __init__(self):
        print('New C instance is created')

c = C() # C.__init__() is automatically called during instance creation.
</code></pre>
<p><code class="inline">__init__()</code> method can get more arguments:</p>

<pre><code class="python">class C:
    def __init__(self, x):
        print('x =', x)

c = C(5) # 'x = 5' is printed during instance object creation.
</code></pre>
<p><code class="inline">__init__()</code> methods are called constructors in computer science literature.</p>

<h3>Callables</h3>
<p>Another special method <code class="inline">__call__()</code> allows creating instances that can be called as if they were functions.</p>

<pre><code class="python">class F:
    def __call__(self, x, y):
        return x + y

f = F()

z = f(1, 2) # The value of z is 3
</code></pre>

<h2>Deleting Entries from Namespaces</h2>
<p>Keyword <code class="inline">del</code> can be used to remove key from dictionary and name from namespace:</p>

<pre><code class="python">def f():
    pass

def g():
    pass

d = {'f':, 'g': g}

# remove key from dictionary
del d['f]

class C:
    def f():
        pass

    def g():
        pass

# remove name from namespace
del C.f
</code></pre>

<h2>Exercises:</h2>
<h3>Exercise 1: Counter</h3>
<p>Implement class which allows making callable instances that have also a variable <code class="inline">count</code> which tells the number of times they were called:</p>

<pre><code class="python">class F:
    ... # implement this

f = F() # create the instance
f()     # call F.__call__(f)

print(f.count)  # Should print 1
f()

print(f.count) # Should print 2
</code></pre>
<h3>Exercise 2: Tic-Tac-Toe </h3>
<p>Implement a tic-tac-toe game. On each turn show the board to the user, ask the user to choose a cell for O, let you algorithm choose a cell for X.
If there are winner or a draw in the end of the turn - stop the game. Otherwise, proceed to next turn.</p>
</div>

<div id="exceptions">
<h1>Exceptions</h1>

<p>Exceptions are errors that occur during the execution of a program. For instance, dividing a num-
ber by zero raises an exception.</p>

<pre><code class="python">57 / 0 # this raises an exception
</code></pre>

<p>The exceptions can be of different types. For instance the operation above raises exception of type ZeroDivisionError.</p>

<p>If the exception is not handled, it stops the execution.  It is possible to handle exceptions. To do this surround
the code section which raises the exception with try and except.</p>

<pre><code class="python">def f(lst):
    try:
        lst[100] = 8
        print('Will this be printed?')
    except Exception:
        pass # Skipping exception without printing any message
             # is not always good idea.

print('Good Morning!')
f([1, 2])
</code></pre>

<p class="question">What does the code above print? Why?</p>
<p>Exception type can be specified after except keyword - only exception of specified type will be handled.
The example above raises IndexError and therefore we could replace <code class="inline">except Exception</code> by <code class="inline">except IndexError</code>:</p>

<pre><code class="python">def f(lst):
    try:
        lst[100] = 8
        print('Will this be printed?')
    except IndexError:
        pass # Skipping exception without printing any message
             # is not always good idea.

print('Good Morning!')
f([1, 2])
</code></pre>

<p>When exceptions are raised, object instances that describe the error are created.
We can access those instances with <code class="inline">as</code> keyword in <code class="inline">except</code> statement:</p>

<pre><code class="python">try:
    57 / 0
except ZeroDivisionError as e:
    print('Error:', str(e))
</code></pre>

<h3>Traceback</h3>
<p>Instead of printing only the error message traceback module can be used to trace back exceptions to their origin.</p>

<pre><code class="python">import traceback

# frozen sets are sets that cannot be changed
s = frozenset({1, 2})

try:
    s.add(0)
except TypeError:
    traceback.print_exc()
</code></pre>

<h3>Raise</h3>
<p>Exceptions can be raised manually using the raise keyword:</p>

<pre><code class="python">raise Exception('Something went wrong')
</code></pre>

<h3>Resource Deallocation</h3>
<p>If unhandled exception is raised in the middle of program execution then the commands that were planned to be executed in the end will not be reached.
<code class="inline">finally</code> construct can be used to handle scenarious where resources should be freed in the end.
Code that is written in finally block is executed whether exception is raised or not.</p>

<pre><code class="python">do_raise = input('Should we raise an exception (answer with y/n)?')

try:
    if do_raise == 'y':
        raise Exception("Stop execution flow")
finnaly:
    print("This should be printed for any do_raise value")
</code></pre>

<p>Another way to free resources even when exception occur is by using <code class="inline">__enter__()</code> and <code class="inline">__exit__()</code> special methods and with statement.</p>

<pre><code class="python">class Resource:
    def __init__(self):
        print('resource object instance created')

    def __enter__(self):
        print('allocating resources')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print('deallocating resources')
        if exc_type:
            raise exc_val
</code></pre>

<p>The first three lines of the output in the code below do not depend on the value of <code class="inline">do_raise</code> variable, it will always be the same:</p>

<pre><code class="python-repl">>>> with Resource():
... do_raise = input('Should we raise an exception (answer with y/n)?')
... if do_raise == 'y':
...     raise Exception("Stop execution flow")
...
resource object instance created
allocating resources
deallocating resources
</code></pre>

<p class="question">Try to run the code above and see what happens.</p>
<p class="question">In the definition of <code class="inline">__exit__()</code> function of the class <code class="inline">Resource</code> above, the exception
is re-raised. Why?</a>
</div>

<div id="comprehensions">

<h1>Comprehensions</h1>
<p>Lists in Python are instances of class list. This class has many functions, for instance <code class="inline">list.append()</code> adds element to a list.</p>

<pre><code class="python">lst = [1, 2, 3, 4]

lst.append(5)

print(lst[4]) # 5 should be printed
</code></pre>
<p>Assume we have a list of number lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10]. One way to create another list, named squares,
which contains square value of every element in lst is to created an empty list and append square values to it:</p>

<pre><code class="python">lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

squares = [] # creating an empty list

for v in lst:
    squares.append(v * v)
</code></pre>
<p>Another way is to use list comprehension. If we we know that one list is created from another, we can
specify the expression and for loop object inside square brackets to create new list:</p>

<pre><code class="python">squares = [v * v for v in lst]
</code></pre>
<p>Both ways create new list named <code class="inline">squares</code> which contains the numbers: 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100.</p>

<p>Itaration which filters some element from the original list can also be converted to list comprehension. Both
of the code snipplets below create new list named <code class="inline">odd_squares</code> which contains the numbers: 1, 9, 25, 49, 81.</p>

<pre><code class="python"># Creating odd_squares with regular for loop

squares = []
for v in lst:
    if v % 2 == 1:
        squares.append(v ** 2)
</code></pre>
<pre><code class="python"># Creating odd_squares using list comprehension

squares = [v ** 2 for v in lst if v % 2 == 1]
</code></pre>
<p>Another exmaple of using list comprehension:</p>

<pre><code class="python"># builtin function range(n, m) returns an object which can
# be converted to list containing all numbers: n, n+1, ..., m-1;
#
# builtin functions ord(letter) return ascii code of a letter.
#
# builtin function chr(code) returns a letter with the given ascii code.

letters_ascii = list(range(ord('A'), ord('Z') + 1))

lst1 = []
for i in letters_ascii:
    lst1.append(chr(i))
    lst2 = [chr(i) for i in letters_ascii]

# lst1 equals lst2 and they both equal a list with english alphabet.
lst1 == lst2 == ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
'U', 'V', 'W', 'X', 'Y', 'Z']
</code></pre>
<h3>Dictionary Comprehension</h3>
<p>Dictionaries can also be created with dictionary comprehension.</p>

<pre><code class="python">ascii_letters = range(ord('A'), ord('Z') + 1)
d = {chr(i): i for i in ascii_letters}
d
</code></pre>
<p class="question">What does variable d contain?</p>
<p>Sets can be created with set comprehension.</p>

<pre><code class="python">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 8, 10]

{i for i in numbers} == set(numbers)
</code></pre>
<h1>Generators</h1>
<p>Generator is a function that can return multiple objects multiple times. Values are returned from
generator using the <code class="inline">yield</code> keywork. Generators can be used in for loops.</p>

<pre><code class="python">def generator():
    yield 1
    yield 2
    yield 3

for i in generator():
    print(i)
</code></pre>
<p>The loop above prints:</p>

<p><code class="inline"></code><code class="inline">
1
2
3
</code><code class="inline"></code></p>

<p>Generators can also be used standalone. For instance, they can be converted to lists.</p>

<pre><code class="python">def range_generator(n):
    i = 0

    while i < n:
        yield i
        i += 1

def range_list(n):
    lst = []
    i = 0
    while i < n:
        lst.append(i)
        i += 1
    return lst

for i in range_list(3):
    print(i)

for i in range_generator(3):
    print(i)

for i in list(range_generator(3)):
    print(i)
</code></pre>
<p>In the sample above, all loops do eventually the same thing: they print numbers from 0 to 2.</p>

<p>Generator is also an object. It is constructed when generator function is called and it can be used in iteration only once.</p>

<pre><code class="python">
values = range_generator(2)
values_as_list = list(values)
print('The values are: ', list(values))

try:
    values = range_generator(2)
    values[0]
except TypeError as e:
    print('Error:', e)
</code></pre>

<p class="question">Why an empty list was printed? Why did the error occur?</p>
<p>Generator function can yield infinite number of times. The following code is legal:</p>

<pre><code class="python">def infinite():
    while True:
        # yielding without a value is the same as yielding None
        yield
</code></pre>
<h3>Generator Comprehensions</h3>
<p>Generators can also be created by using a comprehension. Generator comprehension has the same syntax
as list comprehension with one difference - it is written inside parenthesis instead of square brackets.</p>

<pre><code class="python"># the object comprehension is generator
comprehension = (i * i for i in [1, 2, 3, 4])
</code></pre>

<h3>Builtin Generators</h3>
<p>Many standard library functions are implemented as generators. For instance, the aforementioned <code class="inline">range()</code>
function is in fact a generator. Another popular generator is <code class="inline">enumerate()</code>: it gets as input another
iterable object (it can be list/tuple/another generator/etc.) and creates generator which yields pairs
of values: the first item in every pair is the pair index and the second item is the value at that index
of the original iterator.</p>

<p>This is demonstrated in the following loop execution</p>

<pre><code class="python-repl">>>> letters = 'ABCD'
>>>
>>> for index_letter in enumerate(letters):
...    index = index_letter[0]
...    letter = index_letter[1]
...    print(index, letter)
...
0 'A'
1 'B'
2 'C'
3 'D'
</code></pre>

<p>This loop above could also be written with a syntax more suitable for pairs of values:</p>

<pre><code class="python">letters = 'ABCD'

for index, letter in enumerate(letters):
    print(index, letter)
</code></pre>

<p>As you see in the example above a pair of values can be expanded into two variables.</p>

<h2>Exercises</h2>
<h3>Exercise 1: Natural Numbers</h3>
<p class="question">Write generator comprehension (without <code class="inline">def</code>) that uses <code class="inline">infinite()</code> generator defined above to create new generator
that lists all non-negative integer numbers.</p>

</div>

<div id="functions">
<h1>Functions</h1>

<h2>Function Variables</h2>
<p>In Python, functions are first class citizens: they can be treated as a variable.</p>

<pre><code class="python">
def f():
    print('This is a function')

g = f() # g is a function variable
g()     # calling g() calls in fact f() since f is assign to g
</code></pre>

<h2>Passing Functions as Arguments</h2>
<p>Since functions are treated as variables, they can be passed as arguments to other functions
and returned from other functions.</p>

<pre><code class="python">
def g(f):
    print('f returns', f())

def h():
    return 15

g(h) # prints: f returns 15
</code></pre>

<h2>Asterisks and Arguments</h2>
<p>List can be converted to list of arguments using asterisk syntax:</p>

<pre><code class="python">def f(a, b, c):
    print('a =', a, 'b =', b, 'c =', c)

values = [1, 2, 3]

f(*values) # same as calling f(values[0], values[1], values[2])
</code></pre>
<p>Double asterisk can be used to pass eyword arguments in a similar way:</p>

<pre><code class="python">values = {'a': 1, 'b': 2, 'c': 3}

f(**values) # same as calling f(a=values['a'], b=values['b'], c=values['c'])
</code></pre>

<h2>Variate Number of Arguments</h2>
<p>Asterisk can also be used to declare a function that gets variate number of arguments:</p>

<pre><code class="python">def f(*args):
    print('Number of arguments:', len(args))
</code></pre>
<p>The argument <code class="inline">args</code> in the sample above is a list which may be different on any call:</p>

<pre><code class="python">f('Hello', 'World') # it will print 2 since the number of arguments is 2
</code></pre>
<p>Double asterisk can also be used similarly to get keyword arguments:</p>

<pre><code class="python">def f(**kwargs):
    print('Number of keyword arguments:', len(kwargs)
</code></pre>
<p>The argument <code class="inline">kwargs</code> in the sample above is a dictionary and it contains all arguments passed as keywords:</p>

<pre><code class="python">f(a=2, b=3, u=3) # when f is executed kwargs will be equal {'a': 2, 'b': 3, 'u': 3}
</code></pre>
<p>To sum up, a function in Python can get ordered arguments, keyword arguments, list of ordered arguments, dictionary of keyword arguments:</p>

<pre><code class="python">def f(arg1, argv2, *args_tail, u=2, v=3, **kwtail):
    pass
</code></pre>

<h2>ZIP function</h2>
<p>Builtin function <code class="inline">zip()</code> gets sequence of sequences and returns a sequence where i-th element is a tuple containing the i-th elements
of every input sequence:</p>

<pre><code class="python">lst1 = ['A', B', 'C']
lst2 = [1, 2, 3]

print(list(zip(lst1, lst2))) # Should print [('A', 1), ('B', 2), 'C', 3)]
</code></pre>
<h2>Exercises</h2>
<h3>Exepcise 2: Unzip</h3>
<p class="question">Implement a function unzip which gets the output of <code class="inline">zip()</code> function and returns the input that was passed to <code class="inline">zip()</code> to create
the given output.</p>

<h3>Exercise 1: Enumeration</h3>
<p class="question">Implement <code class="inline">enumerate_list(lst)</code> function which receives a list and returns another list such that
<code class="inline">enumerate_list(lst) == list(enumerate(lst))</code> by using the <code class="inline">zip()</code> function.</p>

</div>

<div>

<h1 id="closures">Closures</h1>
<p>Functions can be defined inside other functions:</p>

<pre><code class="python">def f(a):
    def g(a):
        return a + 9
    return g(a) + 10

f(50)
</code></pre>
<p>Variables are looked up in the most inner scope first. Nested functions cannot be called directly from the surrounding functions.</p>

<p>If a function returns its inner function then all the variables declared inside the outer function are not erased from memory
after function execution since they may be used from within the inner function:</p>

<pre><code class="python">def f():
    lst = []

    def inc():
        lst.append(1)
        return len(lst)

    return inc

i = inc()

i() # this call returns 1
i() # this call returns 2
i() # this call returns 3
...
</code></pre>
<p>Complex example of defining function inside function:</p>

<pre><code class="python">def duplicated(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs) * 2

    return wrapper

def double_length(seq):
    return len(seq)

double_length = duplicated(double_length)
print(double_length('12345'))
</code></pre>
<p>Lets go over the sample above line by line:</p>

<p>Line 1: First we declare <code class="inline">duplicated()</code> function which gets another function as a variable.</p>

<p>Line 2: The we declare an inner function named <code class="inline">wrapper</code> which gets arbitrary ordered and keyword arguments.</p>

<p>Line 3: Inside wrapper we call the function that was passed to <code class="inline">duplicated()</code> (we can do this since inner functions
see variables from the outer functions) and pass to it the arguments that will be passed when someone will
call <code class="inline">wrapper()</code>, we then multiply the result by 2.</p>

<p>Line 5: We return the inner function <code class="inline">wrapper()</code> from <code class="inline">duplicated()</code></p>

<p>Lines 7-8: We declare a function called <code class="inline">double_length</code> that returns the length of any input sequence.</p>

<p>Line 10: We call <code class="inline">duplicated</code> pass the function <code class="inline">double_length()</code> as an argument. When duplicated is executed it creates and then returns
an inner function <code class="inline">wrapper</code> that will, in its turn, return two times the length of any input sequence. We put the returned
function in a function variable <code class="inline">double_length</code>.</p>

<p>Line 11: We print the output of the call to double len with input '12345' (the number 10 will be printed).</p>

<p>We could have spared line 10 in the sample above by using the decorator syntax (which does exactly the same thing):</p>

<pre><code class="python">def duplicated(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs) * 2

    return wrapper

@duplicated
def double_length(seq):
    return len(seq)

print(double_length('12345'))
</code></pre>

<h2>Exercises</h2>
<h3>Exercise 1: Retry</h3>
<p class="question">Implement a decorator retry(n) which runs the decorated function at most n times until no
exceptions are raised. In case of success, the result of the decorated function should be returned.
In case of failure, the last exception should be reraised.</p>
</div>

<div id="pandas">
<h1>Pandas</h1>

<p>Python's scientific stack fame goes before its name. Histrorically, the basis of this stack was the numpy module,
the crux of which is fast, convinient and open source n-dimentional numbers arrays operations library.</p>

<p>Numerous scientific and data analytics packages were built on top of this solid fundament.
One of them is Pandas: data manipulation package.</p>

<p>Another popular package is jupyer: jupyer allows running python code snippets one by one in a web app. The
code-snippets (also called cells) appear on a single web page called a notebook and they can be executed one by one. The
output of every code-snippet immidiately follows its definition in the notebook.  This way of writing new code is very convinient for data analysis.</p>

<p>Notebooks become a de-facto standard for data analysis environments. Therefore, the most natural way to learn
Python's scientific stack libraries is to use them in a Jupyter.</p>

<p>We prepared a notebook with examples of Panda's code.</p>

<p class="question">Please open <a href="python/Pandas.ipynb">Pandas Notebook</a> in Jupyter.
Run the cells one by one and observe what they do.</p>
</div>

<div id="summary">

<h1>Summary</h1>

<h2>Python is...</h2>

<p>Python is a high-level, dynamically typed programming language.<br/>
It supports procedural, functional, object oriented and modular paradigms.<br/>
It uses reference counting for automatic memory management.<br/>
Python is very expressive.<br/>
Python has rich standard library.<br/>
The documentation of Python standard library can be found at <a href="docs.python.org">docs.python.org</a>.<br/>
Python has lots of easily installed modules that enrich the language.</p>

<h2>Solutions</h2>

<p>Solutions to most exercises in this course can be found <a href="python/solutions">here</a>.</p>

</div>

</body>

</html>
